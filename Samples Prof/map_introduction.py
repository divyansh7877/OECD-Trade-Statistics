# -*- coding: utf-8 -*-
"""map_introduction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1R4OHOMZozi-xxi0T7jNPX_K1_QyBM3I_
"""

!pip install geopandas
!pip install geoplot

import geopandas

path_to_data = geopandas.datasets.get_path("nybb")
path_to_data
gdf = geopandas.read_file(path_to_data)

gdf

import geopandas

path_to_data = geopandas.datasets.get_path("nybb")
gdf = geopandas.read_file(path_to_data)

gdf.to_file("my_file.geojson", driver="GeoJSON")
gdf = geopandas.read_file("my_file.geojson", driver="GeoJSON")

gdf

"""### Writing files


"""



gdf = gdf.set_index("BoroName")

gdf["area"] = gdf.area
gdf["area"]

"""### Getting polygon boundary and centroid

"""

gdf["boundary"] = gdf.boundary
gdf["boundary"]

"""Since we have saved boundary as a new column, we now have two geometry columns in the same `GeoDataFrame`.

"""

gdf["centroid"] = gdf.centroid
gdf["centroid"]

"""### Measuring distance

We can also measure how far each centroid is from the first centroid location.
"""

first_point = gdf["centroid"].iloc[0]
gdf["distance"] = gdf["centroid"].distance(first_point)
gdf["distance"]

gdf["distance"].mean()

gdf["category"] = gdf.index
gdf["category"]
gdf.plot("area", legend=True)

#gdf.explore("area", legend=True)

"""Switching the active geometry (`GeoDataFrame.set_geometry`) to centroids, we can plot the same data using point geometry."""

gdf["centroid"] = gdf.centroid
gdf["centroid"]

gdf = gdf.set_geometry("centroid")
gdf.plot("area", legend=True)

"""And we can also layer both `GeoSeries` on top of each other. We just need to use one plot as an axis for the other."""

ax = gdf["geometry"].plot()
ax2 = gdf["centroid"].plot(ax=ax, color = 'r')
gdf = gdf.set_geometry("geometry")
ax3 = gdf.plot("area", ax=ax2, legend=True)
gdf["centroid"].plot(ax=ax3, color = 'r')

"""Now we set the active geometry back to the original `GeoSeries`."""

gdf = gdf.set_geometry("geometry")

"""
## Geometry creation
"""

gdf["convex_hull"] = gdf.convex_hull

# saving the first plot as an axis and setting alpha (transparency) to 0.5
ax = gdf["convex_hull"].plot(alpha=0.5)
# passing the first plot and setting linewitdth to 0.5
gdf["boundary"].plot(ax=ax, color="white", linewidth=0.5)

"""### Buffer

In other cases, we may need to buffer the geometry using `GeoDataFrame.buffer()`. Geometry methods are automatically applied to the active geometry, but we can apply them directly to any `GeoSeries` as well. Let's buffer the boroughs and their centroids and plot both on top of each other.
"""

# buffering the active geometry by 10 000 feet (geometry is already in feet)
gdf["buffered"] = gdf.buffer(1000)

# buffering the centroid geometry by 10 000 feet (geometry is already in feet)
gdf["buffered_centroid"] = gdf["centroid"].buffer(1000)

# saving the first plot as an axis and setting alpha (transparency) to 0.5
ax = gdf["buffered"].plot(alpha=0.5)
# passing the first plot as an axis to the second
gdf["buffered_centroid"].plot(ax=ax, color="red", alpha=0.5)
# passing the first plot and setting linewitdth to 0.5
gdf["boundary"].plot(ax=ax, color="white", linewidth=0.5)

"""<div class="alert alert-info">
User guide
    
See more on [geometry manipulations](../docs/user_guide/geometric_manipulations.rst) in the user guide.
</div>

## Geometry relations

We can also ask about the spatial relations of different geometries. Using the geometries above, we can check which of the buffered boroughs intersect the original geometry of Brooklyn, i.e., is within 10 000 feet from Brooklyn.

First, we get a polygon of Brooklyn.
"""

brooklyn = gdf.loc["Brooklyn", "geometry"]
brooklyn

"""The polygon is a [shapely geometry object](https://shapely.readthedocs.io/en/stable/manual.html#geometric-objects), as any other geometry used in GeoPandas."""

type(brooklyn)

"""Then we can check which of the geometries in `gdf["buffered"]` intersects it."""

gdf["buffered"].intersects(brooklyn)

"""Only Bronx (on the north) is more than 10 000 feet away from Brooklyn. All the others are closer and intersect our polygon.

Alternatively, we can check which buffered centroids are entirely within the original boroughs polygons. In this case, both `GeoSeries` are aligned, and the check is performed for each row.
"""

gdf["within"] = gdf["buffered_centroid"].within(gdf)
gdf["within"]

"""We can plot the results on the map to confirm the finding."""

gdf = gdf.set_geometry("buffered_centroid")
# using categorical plot and setting the position of the legend
ax = gdf.plot(
    "within", legend=True, categorical=True, legend_kwds={"loc": "upper left"}
)
# passing the first plot and setting linewitdth to 0.5
gdf["boundary"].plot(ax=ax, color="black", linewidth=0.5)

"""## Projections

Each `GeoSeries` has its Coordinate Reference System (CRS) accessible at `GeoSeries.crs`. The CRS tells GeoPandas where the coordinates of the geometries are located on the earth's surface. In some cases, the CRS is geographic, which means that the coordinates are in latitude and longitude. In those cases, its CRS is WGS84, with the authority code `EPSG:4326`. Let's see the projection of our NY boroughs `GeoDataFrame`.
"""

gdf.crs

"""Geometries are in `EPSG:2263` with coordinates in feet. We can easily re-project a `GeoSeries` to another CRS, like `EPSG:4326` using `GeoSeries.to_crs()`."""

gdf = gdf.set_geometry("geometry")
boroughs_4326 = gdf.to_crs("E4326"PSG:)
boroughs_4326.plot()

boroughs_4326.crs

"""## EXAMPLES"""

#######
# DOT map
#######

world = geopandas.read_file(geopandas.datasets.get_path('naturalearth_lowres'))
# Get a list (dataframe) of country centroids
centroids = world.centroid
# Plot the results
ax = world.plot(column = 'name')
centroids.plot(ax = ax,  markersize = 5)

#######
# HEAT
#######

import geoplot as gplt
import geoplot.crs as gcrs
import geopandas as gpd

boroughs = gpd.read_file(gplt.datasets.get_path('nyc_boroughs'))
collisions = gpd.read_file(gplt.datasets.get_path('nyc_collision_factors'))

ax = gplt.polyplot(boroughs, projection=gcrs.AlbersEqualArea())
gplt.kdeplot(collisions, ax=ax)

#######
# HeXbin
#######

# Read the mariage data stored on github:
import pandas as pd
# Import geopandas library
import geopandas as gpd

# Load file
url = "https://raw.githubusercontent.com/holtzy/The-Python-Graph-Gallery/master/static/data/us_states_hexgrid.geojson.json"
geoData = gpd.read_file(url)

mariageData = pd.read_csv("https://raw.githubusercontent.com/holtzy/The-Python-Graph-Gallery/master/static/data/State_mariage_rate.csv")

# Add a new column to the geo dataframe that will be used for joining:
geoData['state'] = geoData['google_name'].str.replace(' \(United States\)','')

# Merge the mariage dataset with the geospatial information
geoData = geoData.set_index('state').join(mariageData.set_index('state'))

geoData.plot(column="y_2015", cmap="viridis");

#######
# Choropleth map
#######
import geoplot as gplt
import geoplot.crs as gcrs
import geopandas as gpd

contiguous_usa = gpd.read_file(gplt.datasets.get_path('contiguous_usa'))
contiguous_usa
gplt.choropleth(contiguous_usa, hue='adm1_code')

#######
# Symbol
#######

import geopandas as gpd
world = gpd.read_file(gpd.datasets.get_path("naturalearth_lowres"))

centroids = world.copy()
centroids.geometry = world.centroid
centroids['size'] = centroids['pop_est'] / 1000000  # to get reasonable plotable number

ax = world.plot(facecolor='w', edgecolor='k')
centroids.plot(markersize='size', ax=ax, edgecolor='white')

